110131

directory

ctime( &(sb1.st_mtime)); 

sprintf(size, "%d KB", s/1000);
    combination of printf and strcpy

Q: return pointer? return variable storing pointer?

*dont forget the terminatin null

char * get_perm_string(mode_t mode ){
     mode_t perms[3];
     int i;
     char *perm_string = (char *)malloc(10);
     perm_string[9] = 0;
     perms[0] = ( mode & 0b111000000 ) >> 6; //bitshifting
     perms[1] = ( mode & 0b111000) >> 3;
     perms[2] = ( mode & 0b111);
... // not the best way
}

Directories
    A *nix dir is a file containing the names of the files within the directory along with basic info like file type
    moving files into/out of directory means chaning dir file not actually moving any data

opendir - <dirent.h>
    open a directory file
    will not change cwd, only allows program to read content of dir
    opendir(<PATH>);
    return pointer to directory stream (DIR *)
closedir
    closedir(<DIR STREAM>);
readir(<DS>);
	returns a pointer to next entry in ds or NULL
struct dirent - <sys/types.h>
       dir struct, contain dir info
       data members
       	    d_name: Name of a file
	    d_type: file type as int


110316

getcwd - <unistd.h>
    get current working dir(<str buff>, <size>);
    in absolute path
    from where the program is called, not live
    	 char path[100];
	 path[99] = 0;
	 getcwd(path, 99);

chdir - <unistd.h>
    chdir(<PATH>);
	change the wd of the program! does not get popped or anything
	returns 0 if succ, -1 (errno) if not

command line args (tb...)
    int main( int argc, char *argv[] )
    program name (e.g. ./a.out) is the first command line arg
    argc - number of arguments
    argv - array of char *
"he llo" = he\ llo

scanf - <stdio.h>
    scanf( <FORMAT STRING>, <V1>, <V2>... );
    
    int x;
    printf("\nset the x:");
    scanf("&d", &x);
		^pt
    	your input needs to match the format!
    no need to worry about overflow here-
    BUT STRINGS ARE PROBLEMATIC. POSSIBLE BUFFER OVERFLOW.
    e.g. declare s[10] and enter longer

110416

fgets - <stdio.h>
    read in from file stream, store in string
    fgets( <dest>, <bytes>, <file pt> );
        reads at most <bytes>-1
    FILE POINTER - more complex than file descriptor
    	 stdin is a FILE * variable
    >>stops<< at newline, end of file, or reach byte limit
    	      NEWLINE CHR IS KEPT AS PART OF STRING
	      SHOULD DEAL WITH ACCORDINGLY
    will append NULL after always
NEVER USE GETS

processes
$ ps
TIME is NOT how long CMD has been running
     how long it took in processor
TTY: terminal session identifier
PID: process identification number
     *pid 1 is init
refreshes when rebootps

$ ps -a
all processes attached to terminal sessions (not ALL)
$ ps -ax
ALL

(specific to linux)
/$ ls/proc
   all process running has a folder in /proc


  
110716
are your processes running? then you should go out and catch them

every running program is a process
a process can create subprocesses, which are just processes

a processor can handle 1 process per cycle/core
"multitasking" is an illusion         

getpid() - <unistd.h>
getppid()
   parent process id

signals
  a limited way of sending info to a process
  $ kill <PID>
    	 sends signal 15 (SIGTERM) to PID
  $ kill -signal <PID>
    	 the signal KILL (9) cannot be intercepted
*CTRL C = signal (2) SIGINT
$ kill -11 <PID>
Segmentation fault: 11

stop means suspend, diff from terminate

$ killall [-<SIGNAL>] <PROCESS NAME>
signal all p with pname

in C:
kill(<PID>, <SIGNAL>); //return 0 on succ
#include <signal.h>

v must be this header!
static void sighandler(int signo){ //replace default sighandler
       if ( signo == SIGNIT )
       	  printf("nice try");
}
int main(){
    signal(SIGINT, sighandler); //pass func name as param, is all good
    signal(SIG..., sighandler);
    ...
    return 0;
}

* sleep(1); //waits 1 sec


111016
what the fork

fork() - <unistd.h>
creates separate process based on current one
	new process is child
	original is parent
child process is a duplicate of parent process. it is COPIED, including stack and heap mem and the file table.
returns 0 to child and the childs pid to the parent or -1 (errno)
if parent process end before child, child (orphan process) pid is 1.

int f = fork();

ALL CODE AFTER FORK() IS REPEATED.
parents won't always exit "on the right time".
